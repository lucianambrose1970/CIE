$cat sparkdata.txt

$spark_shell

scala> val data =sc.textfile("sparkdata.txt")
scala> data.collect;

scala>val splitdata =data.flatmap(line =>line.split(" "));

scala> splitdata.collect;

scala> val mapdata = splitdata.map(word => (word,1));  

scala> mapdata.collect;  

scala> val reducedata = mapdata.reduceByKey(_+_);  

scala> reducedata.collect;  


movies rating 

val movies = table("movies")
val ratings = sql("select userId, movieId, rating from ratingsB")
ratings.describe().show
movies.printSchema
ratings.printSchema

To improve our spark coding we can perform whatever query we can think of with learning purposes. 
Firstly, let us check the users that have rated the most and the least number of movies:

import org.apache.spark.sql.functions.count
import org.apache.spark.sql.functions.{desc,asc} 
ratings.groupBy("userId").agg(count("*").alias("number_cnt"))
.orderBy(desc("number_cnt")) 
ratings.groupBy("userId").agg(count("*").alias("number_cnt"))
.orderBy(asc("number_cnt"))

import org.apache.spark.sql.functions._
def movie_grade (df: org.apache.spark.sql.DataFrame, movie: String ) : Unit = df.filter((df("title").contains(movie)))
.groupBy("title").agg((round(avg($"rating"),3)).as("averageStars")).orderBy(desc("averageStars")).show(false)

we will filter the movies with more than 600 rates and display the by their average rate in an ascending and descending way
 to check the worst and the best movies.

val df_count = df_full.groupBy("title").agg(avg("rating").as("averageRating"), 
count("title").as("RatesCount")) 
df_count.withColumn("roundedAverageRating", round(df_count("averageRating"),2)).filter
(df_count("RatesCount") > 600).orderBy(asc("averageRating")).drop("averageRating").show(20, false) 
df_count.withColumn("roundedAverageRating", round(df_count("averageRating"),2)).filter
(df_count("RatesCount") > 600).orderBy(desc("averageRating")).drop("averageRating").show(20, false)


table creation


 CREATE TABLE Movie
    (
        movieId INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        title VARCHAR(255) NOT NULL,
        moviePath VARCHAR(500) NOT NULL
    );

    CREATE TABLE Rating
    (
        rid INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        mid INTEGER FOREIGN KEY REFERENCES Movie(movieId) ON DELETE CASCADE, 
        uid INTEGER FOREIGN KEY REFERENCES User(id) ON DELETE CASCADE,
        rating INTEGER NOT NULL, 
    );

   CREATE TABLE Genre(
       id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
       movieId INTEGER NOT NULL FOREIGN KEY REFERENCES Movie(movieId) ON DELETE CASCADE,
       genre VARCHAR(255) NOT NULL
   );



select t.mid, t.sum_rating,
m.title, m.moviepath, g.genres
from (
  select top 1 mid, 
         sum(rating) as sum_rating
  from rating
  group by mid
  order by sum_rating desc
) t
left join movie m
on m.movieid = t.mid
left join genre g
on g.movieid = m.movieid
;


You could calculate the rating by summing all ratings for a movie in a subquery. Another subquery could calculate the highest rating per genre. By joining them together, you'd filter only the top movies per genre:

select  *
from    Movie m
join    Genre g
on      g.movieId = m.movieId
join    (
        select  r.mid
        ,       sum(Rating) as SumRating
        from    Rating r
        group by
                r.mid
        ) r
on      r.mid = m.movieId
join    (
        select  g.id as gid
        ,       max(SumRating) as MaxGenreRating
        from    (
                select  r.mid
                ,       sum(Rating) as SumRating
                from    Rating r
                group by
                        r.mid
                ) r
        join    Genre g
        on      g.movieId = r.mid
        group by
                g.id
        ) filter
on      filter.gid = g.id
        and filter.MaxGenreRating = r.SumRating




select Movie.movieId, Movie.title, Movie.moviepath
from movie, rating, genre
where
    movie.id = rating.mid and
    movie.id = genre.movieId
order by rating desc
limit 1; // limit is used if you are using MySQL. In other databases you can use suitable sql query.



SELECT mov_title, mov_year, dir_fname, dir_lname, 
       act_fname, act_lname, role 
FROM  movie
NATURAL JOIN movie_direction
NATURAL JOIN movie_cast
NATURAL JOIN director
NATURAL JOIN actor
WHERE mov_time=(SELECT MIN(mov_time) FROM movie);